＜リークチェック＞
valgrindを使用してメモリリークについてもしっかり確認して貰いました
ワカモレのvalgrindにはデフォルトでメモリリークがあるみたいでそれとの差分について確認して貰いました
メモリリークはleaksコマンドを使用して異常系の場合も確認して貰いました
パラメータなしの場合にメモリリークがあり argc==1 の時に free() が呼ばれず、leak していました
引数がない時、引数が一つの時、被っている時、leak
mallocの失敗とかも考慮
free_listでfreeしたものをfreeしていて、crashしてしまいました。exitを使えばfreeしてくれるので使わなくてもいいかもしれません
mallocを使っている関数（例えばft_splitなど）を呼び出す際、malloc失敗時はnullが返されるのでチェック

＜アルゴリズム＞
基本的にはクイックソートで2分割で実装されたそうですが、再帰の終了条件をなるべくsize==3ではなくsize==2になるようにpivotを選択されたそうでした。たしかにsize=6のときでも2のべき乗を意識してpivotを選択すると分割の回数が減らせるなと思いました。(6)->(3,3)->(2, 1, 2, 1)、(6)->(4, 2)->(2,2,2)。
sort4(),sort5(),sort6()は、sort3()に渡す前に何個の数字をpush_count()に処理させるべきかが明示的になるようにcount = 2など変数に代入した上で、引数として渡すコードになっているので、とてもわかりやすく、保守性にも優れていると思いました。
ベースのアプローチは3分割ソートですが、随所に手数を縮める工夫がされていました。要素数5以下となった場合に全探索（DFS）に切り替えるようになっており、大幅な最適化の要因となっているようでした.データ構造には双方向循環リストによるdequeが使用されていました
クイックソートで手数を減らすためにスタックの最小値をスタックAにとどめる処理を追加していて良いと思います。
またstackBからstackAに戻していくときに２個ずつにするだけでもより早くなると思います！
分割して挿入ソートのようなことをするアルゴリズムがわかりやすかったです。
最適化について、'rb pa rrb' -> 'sb pa' にすることで、500要素で100手ぐらい減らせそうです
実装方法も、スタックAにすでにソートされている部分はそのまま残したり
ra,rbがあるところはrrにする
並び替えのコマンドを省略することで手数を減らせる
番兵ノードで先頭や末端ノードを管理する方法、循環リストを引数の数分回す方法、最も小さい値をもつノードを検索する方法を対応策としてお伝えしました

＜コードの書き方アドバイス＞
is_〇〇と命名した関数ではbool値を返して、それをif分の条件式に入れて、処理はまた違う関数でする。
コードをより簡略する書き方について教えていただきました。（３つの数をソートする際の処理。３つの数の大小比較の処理。など）
enum は簡単に使えるので、ぜひ使ってみてください。また、即値をなるべく使わず、define した方が見やすいコードになるかと思います。
main関数の中でしたら、ヒープを mallocしないでも、スタックの変数を使用すると、エラーチェックやフリーが必要ないかもしれません。
エラーハンドルで、エラー時に０を返していますが、一般的に０は正常終了かと思います.マクロでEXIT_FAILUREなどの使用をお勧めします
実際のアクションの前に、エラーチェックをする場合には、その順番で、コードを記載するといいのでは（func action || func error check)
t_nodeのポインタをそのまま持っていたのですが、t_stackのような構造体に抽象化して、sizeなどのメンバーをもたせるとlst_sizeのような関数を複数回呼び出すことがなくパフォーマンスの向上や、データの操作が楽になるかもしれません。

＜エラーハンドリング＞
引数が一つの文字列になってる時にエラーになっていたので、"No"で出させていただきます。
引数が一つのとき、""のときにセグフォしていました
数字が重複していた際にfreeが2度されていおりabortしてしまっていました。
ソートずみのパラメータの入力で、ソートのオペレーションが動いてしまいましたので、その項目はNGにさせていただきました
[引数]○ ○ ○の場合、"○ ○ ○"の場合に対応しており、混合された場合には未対応でした
ダブルクォーテーションで囲われた引数についてErrorを表示することについてはbashで動作するので問題ないと判断しました。
reading zeroを一貫してERRORにできていたところはすごいと思います
...-00001?
INT_MAXを超えた値を引数としたときにErrorが表示されませんでした
"" "+" "-" “ ”など、数字が0文字含まれる文字列が "0" と同じ扱いになっていました
`0 0`, "", " -" など error にならない文字列がありました
./push_swap '' (空文字を渡した場合)、./push_swap $((2**64)) (longをオーバーフローして、intに収まる場合) のエラーハンドリングが不十分です
引数ごとに一つの数値、スペース区切りされた引数、これらが混在するケースに対応されていましたが、空文字列のみやスペース記号のみのケースを無効な引数としてErrorとする一方で、空文字列又はスペース記号のみの引数と数値が入った引数が指定されたケースでは、無効な引数を無視してErrorとせず、解を出力していたため、Error Managementの項目をNoと致しました
コマンドライン引数が「""」「" "」等の場合はErrorとしていながら、「"" ○ ○」「" " ◯ ◯」等の場合は
Errorとせず正常な入力として受け付けていた
push_swap のみ（引数のない）のときにseg fault する
重複する引数を与えた時, 重複が検出されないことがありました。 
nt値への変換の際に空文字列を弾く必要がある
INT_MIN未満の時なぜかエラー処理できていませんでした
引数がTabで区切られていた場合
MAXINT(2147483648 )以上あるいはMININT(-2147483649)以下の値の時はErrorを返さないといけない
"1a"のように、数字の後に文字とかがあった場合でもエラーになっていませんでした
"0000000000000000000001"とかはエラーになってしまっていました
後ろに文字がある場合は、tf_atoiのなかで、「+ - を一回飛ばす」「0~9を飛ばす」「最後の文字がヌル文字でなければfalse」 にすれば弾けます。atoiの中を、INT_MAXとかで弾くと、tf_atoiがすっきりします
引数を渡さなかった場合、errorと出力してはいけない
空白文字だけが与えられた場合セグフォするので、sp_argv[0]がNULLの場合はerrorで弾く方がいいと思います
5の場合12以内に抑える必要があります
exit(0)で抜けており途中のsplitなどを全くfreeしていません。素晴らしいと思います、怒られてください。errorはexit(1)で抜けるべきです
個人的には、タブはerrorではなく考慮すべきだと思いましたが、すべてエラーとして判断されていたのでOKにしておきます
複数の値をひとまとまりの文字列として与えられた時にErrorを出力してしまうので、そこを修正する必要があります。
./push_swap "2 3 +1 -" など、「+」「-」のみの場合0と判定される。 ./push_swap " " ./push_swap "" 何も入ってこない場合もErrorとなります。
+ -が0として認識されてしまっており、文字として認識されていないということでその部分をNOにしています。
パラメーターが"-"か"+"とかだった時にErrorを出力できるといいと思います
errorの文をErrorに直すといいと思います
座標圧縮の際、値をintで保持しているのにindexが0スタートで、INT_MAX個よりも多い数字を渡された際にオーバーフローを起こしてしまう可能性がありましたが、それを実演することが難しいためOKで通しています